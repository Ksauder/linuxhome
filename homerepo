#!/usr/bin/env bash
# This script was generated by bashly 1.2.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
homerepo_usage() {
  printf "homerepo - Sample application\n\n"

  printf "%s\n" "$(cyan "Usage:")"
  printf "  homerepo COMMAND\n"
  printf "  homerepo [COMMAND] --help | -h\n"
  printf "  homerepo --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(cyan "Commands:")"
  printf "  %s   Bootstrap the homedir using dotfiles and config files\n" "$(green "bootstrap")   "
  printf "  %s   Revert the bootstrap and return homedir to previous state (probably)\n" "$(green "unbootstrap") "
  printf "  %s   run an install script by name, will automatically guess the right flavor for your box\n" "$(green "install")     "
  printf "  %s   test things, not sure how this works yet\n" "$(green "test")        "
  printf "  %s   build the docker images used for testing\n" "$(green "build-images")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(cyan "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(blue "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(blue "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(cyan "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(yellow "REPO_ROOT")"
    printf "    root dir of the repo\n"
    printf "    %s\n" "Default: $(dirname $(realpath $0))"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(yellow "BACKUP_DIR")"
    printf "    directory used to backup and restore existing dotfiles\n"
    printf "    %s\n" "Default: ${HOME}/.dotfilebackups"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(yellow "TEST_DIR")"
    printf "\n"
    printf "    %s\n" "Default: ${REPO_ROOT}/tests"
    echo

  fi
}

# :command.usage
homerepo_bootstrap_usage() {
  printf "homerepo bootstrap - Bootstrap the homedir using dotfiles and config files\n\n"
  printf "Alias: b\n"
  echo

  printf "%s\n" "$(cyan "Usage:")"
  printf "  homerepo bootstrap\n"
  printf "  homerepo bootstrap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(cyan "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(blue "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
homerepo_unbootstrap_usage() {
  printf "homerepo unbootstrap - Revert the bootstrap and return homedir to previous state (probably)\n\n"
  printf "Alias: ub\n"
  echo

  printf "%s\n" "$(cyan "Usage:")"
  printf "  homerepo unbootstrap\n"
  printf "  homerepo unbootstrap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(cyan "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(blue "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
homerepo_install_usage() {
  printf "homerepo install - run an install script by name, will automatically guess the right flavor for your box\n\n"
  printf "Alias: i\n"
  echo

  printf "%s\n" "$(cyan "Usage:")"
  printf "  homerepo install\n"
  printf "  homerepo install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(cyan "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(blue "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
homerepo_test_usage() {
  printf "homerepo test - test things, not sure how this works yet\n\n"
  printf "Alias: t\n"
  echo

  printf "%s\n" "$(cyan "Usage:")"
  printf "  homerepo test DISTRO TEST [HOMEREPO_USER]\n"
  printf "  homerepo test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(cyan "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(blue "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(cyan "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(white "DISTRO")"
    printf "    Name of the distribution to test against, a docker container will be used to\n    execute the tests\n"
    printf "    %s\n" "Allowed: debian11, debian12, ubuntu20, ubuntu22, ubuntu24"
    echo

    # :argument.usage
    printf "  %s\n" "$(white "TEST")"
    printf "    Name of test script to run. Scripts are under tests/ dir\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(white "HOMEREPO_USER")"
    printf "    user to use for test\n"
    printf "    %s\n" "Default: ${USER}"
    echo

  fi
}

# :command.usage
homerepo_build_images_usage() {
  printf "homerepo build-images - build the docker images used for testing\n\n"

  printf "%s\n" "$(cyan "Usage:")"
  printf "  homerepo build-images\n"
  printf "  homerepo build-images --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(cyan "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(blue "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# bashly/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# :command.command_functions
# :command.function
homerepo_bootstrap_command() {

  # bashly/commands/bootstrap.sh
  #!/bin/bash

  # required vars
  # REPO_ROOT=$(dirname "$(realpath "$0")")
  # BACKUP_DIR="${HOME}/.dotfilebackups"
  # HOME

  chmod +x ${REPO_ROOT}/scripts/*

  # init any submodules and run any machine setup scripts

  echo "Linking dotfiles"
  mkdir -p ${BACKUP_DIR}
  for file in $(find ${REPO_ROOT}/dotfiles -maxdepth 1 -type f,l); do
      filename=$(basename "${file}")
      echo "- ${HOME}/${filename} -> ${file}"
      if [ -f "${HOME}/${filename}" ] && [ ! -L "${HOME}/${filename}" ]; then
          # FIXME: what if the existing node isn't a file, but instead a symlink?
          mv "$HOME/${filename}" "${BACKUP_DIR}/${filename}.orig.bak"
      fi
      ln -s "$(realpath ${file})" "$HOME/${filename}"
  done
  echo "dotfiles linked"

  echo "Linking config dirs" # TODO: backup any conflicting dirs
  mkdir -p "$HOME/.config"
  for d in $(find ${REPO_ROOT}/config -maxdepth 1 -mindepth 1 -type d); do
      echo "- $HOME/.config/$(basename ${d}) -> $(realpath ${d})"
      ln -s "$(realpath ${d})" "$HOME/.config/$(basename ${d})"
  done
  echo "Done linking config dirs"

}

# :command.function
homerepo_unbootstrap_command() {

  # bashly/commands/unbootstrap.sh
  #!/bin/sh

  # required vars
  # REPO_ROOT=$(dirname "$(realpath "$0")")
  # BACKUP_DIR="${HOME}/.dotfilebackups"
  # HOME

  echo "Unlinking dotfiles"
  for file in $(find ${REPO_ROOT}/dotfiles -maxdepth 1 -type f,l); do
      filename=$(basename "${file}")
      echo "- removing ${HOME}/${filename} -> ${file}"
      if [ -f "${HOME}/${filename}" ] && [ ! -L "${HOME}/${filename}" ]; then
          echo "- replacing ${filename} from ${BACKUP_DIR}"
          mv "${BACKUP_DIR}/${filename}.orig.bak" "$HOME/${filename}"
      else
          rm "${HOME}/${filename}"
      fi
  done

  # FIXME: should BACKUP_DIR hold all backups, including config dirs?
  # check the backup dir for leftovers
  if [ -d "${BACKUP_DIR}" ] && [ -z "$(ls -A "${BACKUP_DIR}")" ]; then
      rm -r "${BACKUP_DIR}"
  else
      echo "Warning: '${BACKUP_DIR}' is not empty or does not exist."
      echo "Leftover backup files:"
      ls -l ${BACKUP_DIR}
  fi

  echo "Unlinking config dirs" # TODO: backup any conflicting dirs
  for d in $(find ${REPO_ROOT}/config -maxdepth 1 -mindepth 1 -type d); do
      echo "- removing $HOME/.config/$(basename ${d}) -> $(realpath ${d})"
      rm "$HOME/.config/$(basename ${d})"
  done
  echo "Done unlinking config dirs"

}

# :command.function
homerepo_install_command() {

  # bashly/commands/install.sh
  echo "# this file is located in 'bashly/commands/install.sh'"
  echo "# code for 'homerepo install' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
homerepo_test_command() {

  # bashly/commands/test.sh
  #!/bin/sh

  # required vars
  # REPO_ROOT=$(realpath $(dirname $0))
  # TEST_DIR=${REPO_ROOT}/tests
  # TEST_IMAGE=debian_12

  #--user $(id -u):$(id -g) \
  docker_test() {
      distro=${args[distro]}
      test=${args[test]}
      testfile="${TEST_DIR}/test_${test}.sh"

      echo "Testing ${test} on ${distro}"
      docker remove -f ${docker_prefix}${distro}

      docker run -t \
          -v ${REPO_ROOT}:${REPO_ROOT} \
          -e REPO_ROOT=${REPO_ROOT} \
          ${docker_prefix}${distro} bash -c "cd ${REPO_ROOT}; sudo -E ${testfile} ${USER}; id;"

      docker commit ${docker_prefix}${distro}
  }

  docker_test

}

# :command.function
homerepo_build_images_command() {

  # bashly/commands/build-images.sh
  build_image() {
      local distro=$1
      docker build --build-arg UID=$(id -u) --build-arg USER=${USER} -f test_dockerfiles/Dockerfile.${distro} -t ${docker_prefix}${distro}:latest .
  }

  for value in "${distros[@]}"; do
      build_image ${value}
  done

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        homerepo_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export REPO_ROOT="${REPO_ROOT:-$(dirname $(realpath $0))}"
  export BACKUP_DIR="${BACKUP_DIR:-${HOME}/.dotfilebackups}"
  export TEST_DIR="${TEST_DIR:-${REPO_ROOT}/tests}"

  env_var_names+=("REPO_ROOT")
  env_var_names+=("BACKUP_DIR")
  env_var_names+=("TEST_DIR")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    bootstrap | b)
      action="bootstrap"
      shift
      homerepo_bootstrap_parse_requirements "$@"
      shift $#
      ;;

    unbootstrap | ub)
      action="unbootstrap"
      shift
      homerepo_unbootstrap_parse_requirements "$@"
      shift $#
      ;;

    install | i)
      action="install"
      shift
      homerepo_install_parse_requirements "$@"
      shift $#
      ;;

    test | t)
      action="test"
      shift
      homerepo_test_parse_requirements "$@"
      shift $#
      ;;

    build-images)
      action="build-images"
      shift
      homerepo_build_images_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      homerepo_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
homerepo_bootstrap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        homerepo_bootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
homerepo_unbootstrap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        homerepo_unbootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="unbootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
homerepo_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        homerepo_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
homerepo_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        homerepo_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['distro']+x} ]]; then
          args['distro']=$1
          shift
        # :argument.case
        elif [[ -z ${args['test']+x} ]]; then
          args['test']=$1
          shift
        # :argument.case
        elif [[ -z ${args['homerepo_user']+x} ]]; then
          args['homerepo_user']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['distro']+x} ]]; then
    printf "missing required argument: DISTRO\nusage: homerepo test DISTRO TEST [HOMEREPO_USER]\n" >&2

    exit 1
  fi
  if [[ -z ${args['test']+x} ]]; then
    printf "missing required argument: TEST\nusage: homerepo test DISTRO TEST [HOMEREPO_USER]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['homerepo_user']:-} ]] || args['homerepo_user']="${USER}"

  # :command.whitelist_filter
  if [[ -n ${args['distro']:-} ]] && [[ ! ${args['distro']:-} =~ ^(debian11|debian12|ubuntu20|ubuntu22|ubuntu24)$ ]]; then
    printf "%s\n" "distro must be one of: debian11, debian12, ubuntu20, ubuntu22, ubuntu24" >&2
    exit 1
  fi

}

# :command.parse_requirements
homerepo_build_images_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        homerepo_build_images_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build-images"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # :command.variables
  # :variable.definition
  declare -g testvar="testval"

  # :variable.definition
  declare -g -a distros=(
    "debian11"
    "debian12"
    "ubuntu20"
    "ubuntu22"
    "ubuntu24"
  )

  # :variable.definition
  declare -g docker_prefix="homerepo_"

  # :command.environment_variables_default
  export REPO_ROOT="${REPO_ROOT:-$(dirname $(realpath $0))}"
  export BACKUP_DIR="${BACKUP_DIR:-${HOME}/.dotfilebackups}"
  export TEST_DIR="${TEST_DIR:-${REPO_ROOT}/tests}"

}

# :command.run
run() {
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a other_args=()
  declare -g -a env_var_names=()
  declare -g -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "bootstrap") homerepo_bootstrap_command ;;
    "unbootstrap") homerepo_unbootstrap_command ;;
    "install") homerepo_install_command ;;
    "test") homerepo_test_command ;;
    "build-images") homerepo_build_images_command ;;
  esac
}

initialize
run "$@"
